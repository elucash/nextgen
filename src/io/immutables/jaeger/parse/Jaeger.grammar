-------------------------------------------------------------------------------
-- Terms
-------------------------------------------------------------------------------

-- Keywords should not be followed by a word identifier without delimiter
keyword:
  'api' ~ 'api' ! [a-zA-Z0-9]
  'type' ~ 'type' ! [a-zA-Z0-9]
  'resource' ~ 'resource' ! [a-zA-Z0-9]
  'request' ~ 'request' ! [a-zA-Z0-9]
  'response' ~ 'response' ! [a-zA-Z0-9]
  'path' ~ 'path' ! [a-zA-Z0-9]
  'query' ~ 'query' ! [a-zA-Z0-9]
  'form' ~ 'form' ! [a-zA-Z0-9]
  'header' ~ 'header' ! [a-zA-Z0-9]
  'get' ~ 'get' ! [a-zA-Z0-9]
  'post' ~ 'post' ! [a-zA-Z0-9]
  'put' ~ 'put' ! [a-zA-Z0-9]
  'delete' ~ 'delete' ! [a-zA-Z0-9]

keyword-values:
  'true' ~ 'true' ! [a-zA-Z0-9]
  'false' ~ 'false' ! [a-zA-Z0-9]

other:
  <at-context> ~ [@][a-zA-Z0-9]+ ! [a-zA-Z0-9]
  <string> ~ ["][^"]*["]
  <decimal> ~ [0-9]+
  <hexadecimal> ~ [#][0-9a-fA-F]+
  -- FIXME if there's no newline at the end of file
  -- lexer breaks, need handle
  <comment-newline> ~ [/][/][^\n]*[\n]
  <newline> ~ [\n]

-- Only forcing the priority order for compound operators
delimiters:
  '::' ~ '::'
  '??' ~ '??'
  '||' ~ '||'
  '&&' ~ '&&'
  '^^' ~ '^^'
  ':=' ~ ':='
  '==' ~ '=='
  '!=' ~ '!='
  '++' ~ '++'
  '+=' ~ '+='
  '-=' ~ '-='
  '*=' ~ '*='
  '/=' ~ '/='
  '%=' ~ '%='
  '--' ~ '--'
  '->' ~ '->'
  '<-' ~ '<-'
  '-' ~ '-'
  '<=' ~ '<='
  '>=' ~ '>='
  '>..' ~ '>..'
  '..<' ~ '..<'
  '...' ~ '...'
  '..' ~ '..'
  '.' ~ '.'
  ':' ~ ':'
  '=' ~ '='
  '+' ~ '+'
  '/' ~ '/'
  '<' ~ '<'
  '>' ~ '>'
  '?' ~ '?'
  '%' ~ '%'
  '*' ~ '*'
  '?' ~ '?'
  '!' ~ '!'
  '|' ~ '|'
  '&' ~ '&'

identifier:
  <typename> ~ [A-Z][a-zA-Z0-9]*
  <name> ~ [a-z][a-zA-Z0-9_]*
  <name-quoted> ~ [\u0060][^\u0060]*[\u0060] -- escape mode for the identifier

-- lists terms which are skipped by parser
ignored:
  <spacing> ~ [\s\r\t]+

-------------------------------------------------------------------------------
-- Productions
-------------------------------------------------------------------------------

unit
  elements:unit-element+

unit-element
  | api
  | resource
  | operation
  | empty

--  | type-declaration

(leading-comment)
  leading-comment:<comment-newline>*

(trailing-comment)
  trailing-comment:<comment-newline>?

empty
  leading-comment <newline>

api
  leading-comment 'api' literal-record

resource
  leading-comment 'resource' literal-string

operation
  leading-comment http-method name:name '{' feature:operation-feature* '}'

operation-feature
  leading-comment operation-parameter-kind name:name trailing-comment <newline>*

(http-method)
  | method:'get'
  | method:'post'
  | method:'put'
  | method:'delete'

nl
  | <newline>
  | <comment-newline>

local-binding
  leading-comment to:name ':' from:expression-literal

name
  | name:<name>
  | name:<name-quoted>

(operation-parameter-kind)
  | kind:'path'
  | kind:'query'
  | kind:'form'
  | kind:'header'

rest-request
  'request' type:type-reference nl

rest-response
  'response' status:<decimal> type:type-reference nl

type-declaration
  'type' name:<typename> type-parameters? constructor:constructor type-constraints* features:features? nl?

constructor
  | constructor-parameter
  | constructor-cases

constructor-parameter
  input:parameter

constructor-cases
  '{' cases:constructor-case* nl* '}'

constructor-case
  nl* name:<typename> constructor:parameter? features:features?

concept-declaration
  'concept' name:<typename> type-parameters? type-constraints* features:features nl?

(type-parameters)
  '<' type-parameter:<typename> (',' type-parameter:<typename>)* '>'

parameter
  | parameter-product
  | parameter-record

parameter-product
  | '(' nl* ')'
  | '(' fields:named-parameters (field-separator fields:named-parameters)* field-separator? ')'

parameter-record
  | '{' nl* '}'
  | '{' fields:named-parameters-bind (field-separator fields:named-parameters-bind)* field-separator? '}'

(field-separator)
  | ',' nl?
  | nl

-- a, b Number
named-parameters
  nl* name:name type:type-reference

-- a, b Bool: true
named-parameters-bind
  nl* name:name type:type-reference (':' expression-literal)?

-- A | B | C
type-reference-variant
  alternative:type-reference-invariant (nl? '|' nl? alternative:type-reference-invariant)+

-- (Aa, Bb)
type-reference-product
  | '(' nl* ')'
  | '(' component:type-reference (field-separator component: type-reference)* field-separator? ')'

type-reference
  | type-reference-record
  | type-reference-array
  | type-reference-declared

-- {x, y, z int, comment String}
-- { } make illegal?
type-reference-record
  | '{' nl* '}'
  | '{' fields:named-parameters (field-separator fields:named-parameters)* field-separator? '}'

type-reference-array
  '[' component:type-reference ']'

-- a~
-- a?
-- Aridna...
type-reference-invariant
  | type-reference-sequence
  | type-reference-optional
  | type-reference-slot
  | type-reference-undecorated

-- (A,B)
-- {x, y Int}
-- [Elem]
-- A<B>
type-reference-undecorated
  | type-reference-product
  | type-reference-record
  | type-reference-array
  | type-reference-declared

-- Elem...
type-reference-sequence
  component:type-reference-undecorated '...'

type-reference-optional
  component:type-reference-undecorated '?'

type-reference-slot
  component:type-reference-undecorated '~'

-- String
-- Box<Nail>
type-reference-declared
  name:<typename> optional:'?'?

-- <A, B, C>
(type-arguments)
  '<' argument:type-reference (',' argument:type-reference)* '>'

-- :: A == B, C<D>
(type-constraints)
   nl? '::' constraint:type-constraint (',' constraint:type-constraint)*

type-constraint
  | type-constraint-equivalence
  | type-constraint-conception

-- T == Box<Y>
type-constraint-equivalence
  left:type-reference '==' right:type-reference

-- Eq<A>
type-constraint-conception
  concept:type-reference-declared

features
  | '{' nl* '}'
  | '{' element:named-parameters-bind (nl element:named-parameters-bind)* nl? '}'

features-element-local
  nl* binding:local-binding

feature-operator-prefix
  nl* operator-prefix right:operand-parameter output:return-type? type-constraints* impl:statements?

feature-operator-infix
  nl* left:operand-parameter operator-infix right:operand-parameter output:return-type? type-constraints* impl:statements?

feature-operator-postfix
  nl* left:operand-parameter operator-postfix output:return-type? type-constraints* impl:statements?

operand-parameter
  | parameter
  | type-reference-product

feature-named
  nl* name:<name> type-parameters? input:parameter? output:return-type? type-constraints* impl:statements?

return-type
  !'{' component:type-reference (',' component:type-reference)*

statements
  '{' statement:statements-element* nl? '}'

let-binding
  to:name-binding '=' from:expressions

-- type should be valid
slot-binding
  to:name-binding type:type-reference-slot ':=' init:expression

name-binding
  component:name (',' component:name)*

expressions
  component:expression (',' component:expression)*

statements-element
  | empty
  | local-binding
  | statement-expression
  | expression-effect
  | expression

expression-or-statement
  | expression
  | statement-expression

statement-expression
  | statement-return
  | statement-if
  | statement-for

statement-for
  'for' (to:name-binding '<-')? from:expression (nl? 'if' condition:expression)? yield:statements

statement-return
  'return' value:expression-or-statement?

statement-if
  | statement-if-guard
  | statement-if-else

statement-if-guard
  | 'if' condition:if-condition 'else' otherwise:statement-return
  | 'if' condition:if-condition then:statement-return

statement-if-else
  'if' condition:if-condition then:statements (nl? 'else' nl? otherwise:statement-else-if)

statement-else-if
  | statement-if-else
  | statement-else

statement-else
  otherwise:statements?

if-condition
  | expression
  | condition-pattern

condition-pattern
  to:pattern-binding '=' from:expressions

pattern-binding
  | name-binding

expression
  | expression-logical

expression-logical
  left:expression-relational (nl? operator-infix-logical nl? right:expression-relational)*

expression-relational
  left:expression-additive (nl? operator-infix-relational nl? right:expression-additive)?

expression-additive
  left:expression-multiplicative (nl? operator-infix-additive nl? right:expression-multiplicative)*

expression-multiplicative
  left:expression-ranging (nl? operator-infix-multiplicative nl? right:expression-ranging)*

expression-ranging
  left:expression-unary (operator-infix-ranging right:expression-unary)?

expression-unary
  operator-prefix? right:expression-access

expression-access
  base:expression-literal (nl? '.' nl? feature:feature-application)*

expression-effect
  | expression-effect-mutative
  | expression-effect-assigning

expression-effect-mutative
  left:expression operator-postfix-mutative

expression-effect-assigning
  left:expression operator-infix-assigning right:expression

feature-application
  name:name argument:argument?

argument
  | literal-product
  | literal-record
  | literal-sequence

expression-literal
  | literal-reference
  | literal-product
  | literal-sequence
  | literal-constructor
  | literal-bool
  | literal-string
  | literal-number-decimal
  | literal-number-hexadecimal

literal-constructor
  type:<typename> argument:argument?

literal-product
  | '(' nl* ')'
  | '(' component:expression-literal (field-separator component:expression-literal)* field-separator? ')'

literal-record
  | '{' nl* '}'
  | '{' field:field-expression (field-separator field:field-expression)* field-separator? '}'

literal-sequence
  | '[' nl* ']'
  | '[' component:expression-literal (field-separator component:expression-literal)* field-separator? ']'

field-expression
  nl* name:<name> ':' nl* value:expression-or-statement

component-expression
  nl* value:expression-or-statement

literal-reference
  name:name

literal-string
  literal:<string>

literal-number-decimal
  literal:<decimal>

literal-number-hexadecimal
  literal:<hexadecimal>

literal-bool
  | literal:'true'
  | literal:'false'

(operator-prefix)
  | operator:'-'
  | operator:'!'

(operator-postfix)
  | operator-postfix-mutative

(operator-postfix-mutative)
  | operator:'--'
  | operator:'++'

(operator-infix)
  | operator-infix-additive
  | operator-infix-multiplicative
  | operator-infix-relational
  | operator-infix-logical
  | operator-infix-assigning

(operator-infix-multiplicative)
  | operator:'/'
  | operator:'*'
  | operator:'%'

(operator-infix-ranging)
  | operator:'>..'
  | operator:'..<'
  | operator:'..'

(operator-infix-additive)
  | operator:'+'
  | operator:'-'

(operator-infix-relational)
  | operator:'<'
  | operator:'<='
  | operator:'>'
  | operator:'>='
  | operator:'=='
  | operator:'!='

(operator-infix-assigning)
  | operator:':='
  | operator:'+='
  | operator:'-='
  | operator:'*='
  | operator:'/='
  | operator:'%='

(operator-infix-logical)
  | operator:'&&'
  | operator:'||'
  | operator:'^^'
